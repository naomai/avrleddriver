/*
 * pwm.c
 *
 * Created: 14.12.2019 14:44:31
 *  Author: bun
 */ 

#include "pwm.h"
#include "pwm_lowlevel.h"
#include "../LedHardware.h"
#include <string.h>

/*const uint8_t PROGMEM linearBrightnessLut[256]={
	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
	0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
	0x02,0x02,0x02,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
	0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x05,
	0x05,0x05,0x05,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x07,0x07,0x07,0x07,0x07,0x07,
	0x08,0x08,0x08,0x08,0x08,0x08,0x09,0x09,0x09,0x09,0x0A,0x0A,0x0A,0x0A,0x0A,0x0B,
	0x0B,0x0B,0x0B,0x0C,0x0C,0x0C,0x0C,0x0D,0x0D,0x0D,0x0E,0x0E,0x0E,0x0F,0x0F,0x0F,
	0x10,0x10,0x10,0x11,0x11,0x11,0x12,0x12,0x13,0x13,0x14,0x14,0x14,0x15,0x15,0x16,
	0x16,0x17,0x17,0x18,0x18,0x19,0x1A,0x1A,0x1B,0x1B,0x1C,0x1D,0x1D,0x1E,0x1E,0x1F,
	0x20,0x21,0x21,0x22,0x23,0x24,0x24,0x25,0x26,0x27,0x28,0x29,0x29,0x2A,0x2B,0x2C,
	0x2D,0x2E,0x2F,0x30,0x31,0x33,0x34,0x35,0x36,0x37,0x38,0x3A,0x3B,0x3C,0x3E,0x3F,
	0x40,0x42,0x43,0x45,0x46,0x48,0x49,0x4B,0x4D,0x4E,0x50,0x52,0x54,0x56,0x57,0x59,
	0x5B,0x5D,0x5F,0x62,0x64,0x66,0x68,0x6A,0x6D,0x6F,0x72,0x74,0x77,0x79,0x7C,0x7F,
	0x82,0x84,0x87,0x8A,0x8D,0x90,0x94,0x97,0x9A,0x9E,0xA1,0xA5,0xA8,0xAC,0xB0,0xB4,
	0xB8,0xBC,0xC0,0xC4,0xC8,0xCD,0xD1,0xD6,0xDB,0xDF,0xE4,0xE9,0xEE,0xF4,0xF9,0xFF
};*/

const uint16_t PROGMEM linearBrightnessLut[256]={
	0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x02,
	0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
	0x03,0x03,0x03,0x03,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x05,0x05,0x05,0x05,
	0x05,0x05,0x06,0x06,0x06,0x06,0x06,0x06,0x07,0x07,0x07,0x07,0x07,0x08,0x08,0x08,
	0x08,0x09,0x09,0x09,0x09,0x0A,0x0A,0x0A,0x0A,0x0B,0x0B,0x0B,0x0C,0x0C,0x0C,0x0D,
	0x0D,0x0D,0x0E,0x0E,0x0F,0x0F,0x0F,0x10,0x10,0x11,0x11,0x12,0x12,0x13,0x13,0x14,
	0x14,0x15,0x16,0x16,0x17,0x18,0x18,0x19,0x1A,0x1A,0x1B,0x1C,0x1D,0x1D,0x1E,0x1F,
	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2E,0x2F,0x30,
	0x32,0x33,0x34,0x36,0x37,0x39,0x3A,0x3C,0x3E,0x3F,0x41,0x43,0x45,0x47,0x49,0x4B,
	0x4D,0x4F,0x51,0x53,0x56,0x58,0x5B,0x5D,0x60,0x62,0x65,0x68,0x6B,0x6E,0x71,0x74,
	0x77,0x7A,0x7E,0x81,0x85,0x88,0x8C,0x90,0x94,0x98,0x9C,0xA1,0xA5,0xAA,0xAE,0xB3,
	0xB8,0xBD,0xC2,0xC8,0xCD,0xD3,0xD9,0xDF,0xE5,0xEB,0xF2,0xF8,0xFF,0x106,0x10E,0x115,
	0x11D,0x125,0x12D,0x135,0x13D,0x146,0x14F,0x158,0x162,0x16C,0x176,0x180,0x18B,0x196,0x1A1,0x1AC,
	0x1B8,0x1C4,0x1D1,0x1DD,0x1EB,0x1F8,0x206,0x214,0x223,0x232,0x242,0x252,0x262,0x273,0x284,0x296,
	0x2A8,0x2BB,0x2CE,0x2E2,0x2F6,0x30B,0x321,0x337,0x34D,0x365,0x37D,0x395,0x3AE,0x3C8,0x3E3,0x3FF
};


// table of LED turnoff events: time + bitNumber
static PWMEvent PWMTable[STRIPS_COUNT*MAX_CHANNELS_PER_LIGHT];
// table pointing to elements from PWMTable in sorted order
static PWMEvent* PWMTableSorted[STRIPS_COUNT*MAX_CHANNELS_PER_LIGHT];
static uint8_t PWMTableCount;

static void pwmMoveShortEvents();
static void addPWMItem(uint8_t offset, uint8_t bit);

void initPwm(){
	initPwmLow();	
}

bool pwmIsReady(){
	return !swapPending;
	//return true;
}


void pwmPrepareStart() {
	PWMTableCount = 0;
	//PWMTableOffset = 0;
	workBuffer.extenderMask = 0;
}


void pwmBufferLight(light_s *s){
	lightType type = s->hardwareConfig.type;
	
	if(type&LIGHT_RED)
		addPWMItem(s->color.rgb.r, s->hardwareConfig.pins[0]);
	if(type&LIGHT_GREEN)
		addPWMItem(s->color.rgb.g, s->hardwareConfig.pins[1]);
	if(type&LIGHT_BLUE)
		addPWMItem(s->color.rgb.b, s->hardwareConfig.pins[2]);
	if(type&LIGHT_WHITE)
		addPWMItem(s->color.white.w, s->hardwareConfig.pins[3]);
	if(type&LIGHT_WHITEWARM)
		addPWMItem(s->color.cct.warm, s->hardwareConfig.pins[4]);
}

void pwmPrepareFinish() {
	PWMEvent *currentEvent = PWMTableSorted[0], *nextEvent;
	PWMPrecalcEvent *precalcPrev, *precalcCurrent;
	uint8_t precalcCount = 1;
	
	precalcPrev = &workBuffer.precalcTable[0];
	precalcPrev->delay = 0;
	precalcPrev->ticks = 0;
	precalcPrev->portMask = workBuffer.extenderMask;
	precalcCurrent = &workBuffer.precalcTable[1];
	precalcCurrent->delay = 0;
	
	uint16_t currentMask=workBuffer.extenderMask;
	//uint16_t prevMask=currentMask;
	uint16_t nextMask;
	
	PWMOFFSET_VARTYPE currentOffset=0, previousOffset = 0;
	
	for (uint8_t i = 0; i < PWMTableCount; i++) {
		//if(currentMask == 0) break;
		
		currentEvent = PWMTableSorted[i];
		currentMask &= ~(1 << currentEvent->bit);
		
		// set only once for offset/mask
		if(!precalcCurrent->delay){
			currentOffset = currentEvent->offset;
			precalcCurrent->delay = currentOffset - previousOffset;
			precalcCurrent->ticks = 0;

		}
		precalcCurrent->portMask = currentMask;		
		
		/*if(currentMask == prevMask) {
			//precalcPrev->ticks += precalcCurrent->delay;
			//previousOffset = currentOffset;
			continue;
		}*/

		
		//foreshadow - merge events happening at the same time or having the same bit mask
		nextEvent = PWMTableSorted[i+1];
		nextMask = currentMask & ~(1 << nextEvent->bit);
		
		bool sameOffset = nextEvent->offset == currentOffset;
		bool sameMask = nextMask == currentMask;
		bool lastIteration = (i >= PWMTableCount - 1);
		
		// move to next empty position in precalc table
		if((!sameOffset && !sameMask) || lastIteration){
			precalcPrev->ticks = precalcCurrent->delay;
			
			
			precalcPrev = precalcCurrent;
			precalcCurrent++;
			previousOffset = currentOffset;
			precalcCount++;
			if(!lastIteration){ // for "set only once"
				precalcCurrent->delay = 0;
			}
		}
		//prevMask = currentMask;
	}
	precalcPrev->ticks = PWM_RESOLUTION-currentOffset;

	//workBuffer.endingMask = currentMask;
	pwmMoveShortEvents();
	workBuffer.precalcCount = precalcCount;
	
	swapPending = 1;
	
}

void pwmMoveShortEvents(){
	// short pulses moved at bottom, processed with more precise routine
	uint8_t precalcCount = workBuffer.precalcCount;
	uint8_t bigCount = precalcCount, smallCount = 0;
	uint8_t bottomPtr = count(workBuffer.precalcTable);
	PWMOFFSET_VARTYPE bigIntervalsLength = 0;
	PWMPrecalcEvent *precalcCurrent;
		
	/*for(uint8_t i=0; i<precalcCount; i++){
		precalcCurrent = &workBuffer.precalcTable[i];*/
	uint8_t currentIdx = 0;
	while(currentIdx < bigCount){
		precalcCurrent = &workBuffer.precalcTable[currentIdx];
		/*if(precalcCurrent->ticks < PWM_SHORTPULSE){
			workBuffer.precalcTable[--bottomPtr] = *precalcCurrent;
			//memcpy(&workBuffer.precalcTable[--bottomPtr], precalcCurrent, sizeof(PWMPrecalcEvent));
			bigCount--;
			*precalcCurrent = workBuffer.precalcTable[bigCount];
			//memcpy(precalcCurrent, &workBuffer.precalcTable[bigCount], sizeof(PWMPrecalcEvent));
			smallCount++;
		}else{*/
			bigIntervalsLength += precalcCurrent->ticks;
			currentIdx++;
		//}
	}
	
	PWMOFFSET_VARTYPE longestTicks=PWM_LONGPULSE, longestOffset=0, offset=0;
	for(uint8_t i=0; i<bigCount; i++){
		precalcCurrent = &workBuffer.precalcTable[i];
		if(precalcCurrent->ticks > longestTicks){
			longestTicks = precalcCurrent->ticks;
			//longestOffset = offset;
		}
		//offset += precalcCurrent->ticks;
	}
		
	workBuffer.bigIntervalsEndOffset = bigIntervalsLength;
	workBuffer.smallIntervalsPointer = bottomPtr;
	//workBuffer.longestEventOffset = longestOffset;
	workBuffer.longestEventTicks = longestTicks;
}





void addPWMItem(uint8_t offset, uint8_t bit)   {
	PWMOFFSET_VARTYPE offsetCorrected;
	
	if (offset == 0) return; // never turns on
	workBuffer.extenderMask |= 1 << bit;
	if (offset == 255) return; // never turns off
	
	//gamma correction
	offsetCorrected = pgm_read_word(&linearBrightnessLut[offset]);

	PWMEvent newItem;
	newItem.offset = offsetCorrected;
	newItem.bit = bit;
	
	uint8_t ptCount = PWMTableCount;
	
	PWMTable[ptCount] = newItem;
	PWMTableSorted[ptCount] = &PWMTable[ptCount];

	if(ptCount){
		//insertion sort
		for (int8_t i = ptCount-1; i >= 0; i--) {
			if ( newItem.offset < PWMTableSorted[i]->offset) {
				PWMTableSorted[i + 1] = PWMTableSorted[i];
				PWMTableSorted[i] = &PWMTable[ptCount];
			}
			else {
				break;
			}
		}
	}
	PWMTableCount++;
	
}